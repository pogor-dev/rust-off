//! Generated by `cargo xtask codegen grammar`, do not edit by hand.

#![allow(bad_style, missing_docs, unreachable_pub)]
use crate::Edition;
#[doc = r" The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT`."]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
    L_BRACK,
    R_BRACK,
    FALSE_KW,
    NULL_KW,
    TRUE_KW,
    HEX_STRING,
    INT_NUMBER,
    LITERAL_STRING,
    NAME,
    REAL_NUMBER,
    COMMENT,
    ERROR,
    NEWLINE,
    WHITESPACE,
    ARRAY_EXPR,
    EXPR,
    LITERAL,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
impl SyntaxKind {
    #[allow(unreachable_patterns)]
    pub const fn text(self) -> &'static str {
        match self {
            TOMBSTONE | EOF | __LAST | HEX_STRING | INT_NUMBER | LITERAL_STRING | NAME | REAL_NUMBER | ARRAY_EXPR | EXPR | LITERAL | COMMENT | ERROR
            | NEWLINE | WHITESPACE => panic!("no text for these `SyntaxKind`s"),
            L_BRACK => "[",
            R_BRACK => "]",
            FALSE_KW => "false",
            NULL_KW => "null",
            TRUE_KW => "true",
        }
    }
    #[doc = r" Checks whether this syntax kind is a strict keyword for the given edition."]
    #[doc = r" Strict keywords are identifiers that are always considered keywords."]
    pub fn is_strict_keyword(self, edition: Edition) -> bool {
        matches!(self, FALSE_KW | NULL_KW | TRUE_KW)
            || match self {
                _ => false,
            }
    }
    #[doc = r" Checks whether this syntax kind is a weak keyword for the given edition."]
    #[doc = r" Weak keywords are identifiers that are considered keywords only in certain contexts."]
    pub fn is_contextual_keyword(self, edition: Edition) -> bool {
        match self {
            _ => false,
        }
    }
    #[doc = r" Checks whether this syntax kind is a strict or weak keyword for the given edition."]
    pub fn is_keyword(self, edition: Edition) -> bool {
        matches!(self, FALSE_KW | NULL_KW | TRUE_KW)
            || match self {
                _ => false,
            }
    }
    pub fn is_punct(self) -> bool { matches!(self, L_BRACK | R_BRACK) }
    pub fn is_literal(self) -> bool { matches!(self, HEX_STRING | INT_NUMBER | LITERAL_STRING | NAME | REAL_NUMBER) }
    pub fn from_keyword(ident: &str, edition: Edition) -> Option<SyntaxKind> {
        let kw = match ident {
            "false" => FALSE_KW,
            "null" => NULL_KW,
            "true" => TRUE_KW,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_contextual_keyword(ident: &str, edition: Edition) -> Option<SyntaxKind> {
        let kw = match ident {
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            '[' => L_BRACK,
            ']' => R_BRACK,
            _ => return None,
        };
        Some(tok)
    }
}
#[macro_export]
macro_rules ! T { ['['] => { $ crate :: SyntaxKind :: L_BRACK } ; [']'] => { $ crate :: SyntaxKind :: R_BRACK } ; [false] => { $ crate :: SyntaxKind :: FALSE_KW } ; [null] => { $ crate :: SyntaxKind :: NULL_KW } ; [true] => { $ crate :: SyntaxKind :: TRUE_KW } ; [lifetime_ident] => { $ crate :: SyntaxKind :: LIFETIME_IDENT } ; [int_number] => { $ crate :: SyntaxKind :: INT_NUMBER } ; [ident] => { $ crate :: SyntaxKind :: IDENT } ; [string] => { $ crate :: SyntaxKind :: STRING } ; [shebang] => { $ crate :: SyntaxKind :: SHEBANG } ; }
