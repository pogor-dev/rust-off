//! Generated by `cargo xtask codegen grammar`, do not edit by hand.

#![allow(non_snake_case)]
use crate::{
    ast::{self, support, AstChildren, AstNode},
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken, T,
};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Array {
    pub(crate) syntax: SyntaxNode,
}
impl Array {
    #[inline]
    pub fn direct_object(&self) -> Option<DirectObject> { support::child(&self.syntax) }
    #[inline]
    pub fn direct_objects(&self) -> AstChildren<DirectObject> { support::children(&self.syntax) }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Body {
    pub(crate) syntax: SyntaxNode,
}
impl Body {
    #[inline]
    pub fn objects(&self) -> AstChildren<Object> { support::children(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Boolean {
    pub(crate) syntax: SyntaxNode,
}
impl Boolean {
    #[inline]
    pub fn false_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![false]) }
    #[inline]
    pub fn true_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![true]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CrossRefEntry {
    pub(crate) syntax: SyntaxNode,
}
impl CrossRefEntry {
    #[inline]
    pub fn f_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![f]) }
    #[inline]
    pub fn int_number_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![int_number]) }
    #[inline]
    pub fn n_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![n]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CrossRefSection {
    pub(crate) syntax: SyntaxNode,
}
impl CrossRefSection {
    #[inline]
    pub fn cross_ref_entrys(&self) -> AstChildren<CrossRefEntry> { support::children(&self.syntax) }
    #[inline]
    pub fn int_number_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![int_number]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CrossRefTable {
    pub(crate) syntax: SyntaxNode,
}
impl CrossRefTable {
    #[inline]
    pub fn cross_ref_sections(&self) -> AstChildren<CrossRefSection> { support::children(&self.syntax) }
    #[inline]
    pub fn dictionary(&self) -> Option<Dictionary> { support::child(&self.syntax) }
    #[inline]
    pub fn trailer_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![trailer]) }
    #[inline]
    pub fn xref_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![xref]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DictEntry {
    pub(crate) syntax: SyntaxNode,
}
impl DictEntry {
    #[inline]
    pub fn key(&self) -> Option<Key> { support::child(&self.syntax) }
    #[inline]
    pub fn value(&self) -> Option<Value> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Dictionary {
    pub(crate) syntax: SyntaxNode,
}
impl Dictionary {
    #[inline]
    pub fn dict_entrys(&self) -> AstChildren<DictEntry> { support::children(&self.syntax) }
    #[inline]
    pub fn l_dict_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<<]) }
    #[inline]
    pub fn r_dict_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>>]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Header {
    pub(crate) syntax: SyntaxNode,
}
impl Header {
    #[inline]
    pub fn version(&self) -> Option<PdfVersion> { support::child(&self.syntax) }
    #[inline]
    pub fn pdf_marker_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![pdf_marker]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct HexString {
    pub(crate) syntax: SyntaxNode,
}
impl HexString {
    #[inline]
    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }
    #[inline]
    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }
    #[inline]
    pub fn hex_string_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![hex_string]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndirectReference {
    pub(crate) syntax: SyntaxNode,
}
impl IndirectReference {
    #[inline]
    pub fn R_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![R]) }
    #[inline]
    pub fn int_number_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![int_number]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Integer {
    pub(crate) syntax: SyntaxNode,
}
impl Integer {
    #[inline]
    pub fn int_number_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![int_number]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Key {
    pub(crate) syntax: SyntaxNode,
}
impl Key {
    #[inline]
    pub fn name(&self) -> Option<Name> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralString {
    pub(crate) syntax: SyntaxNode,
}
impl LiteralString {
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
    #[inline]
    pub fn literal_string_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![literal_string]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}
impl Name {
    #[inline]
    pub fn slash_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![/]) }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Null {
    pub(crate) syntax: SyntaxNode,
}
impl Null {
    #[inline]
    pub fn null_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![null]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Object {
    pub(crate) syntax: SyntaxNode,
}
impl Object {
    #[inline]
    pub fn object_data(&self) -> Option<ObjectData> { support::child(&self.syntax) }
    #[inline]
    pub fn object_i_d(&self) -> Option<ObjectID> { support::child(&self.syntax) }
    #[inline]
    pub fn endobj_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![endobj]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ObjectID {
    pub(crate) syntax: SyntaxNode,
}
impl ObjectID {
    #[inline]
    pub fn int_number_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![int_number]) }
    #[inline]
    pub fn obj_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![obj]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PdfDocument {
    pub(crate) syntax: SyntaxNode,
}
impl PdfDocument {
    #[inline]
    pub fn body(&self) -> Option<Body> { support::child(&self.syntax) }
    #[inline]
    pub fn header(&self) -> Option<Header> { support::child(&self.syntax) }
    #[inline]
    pub fn trailer(&self) -> Option<Trailer> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PdfVersion {
    pub(crate) syntax: SyntaxNode,
}
impl PdfVersion {
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }
    #[inline]
    pub fn int_number_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![int_number]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Real {
    pub(crate) syntax: SyntaxNode,
}
impl Real {
    #[inline]
    pub fn real_number_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![real_number]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Stream {
    pub(crate) syntax: SyntaxNode,
}
impl Stream {
    #[inline]
    pub fn dictionary(&self) -> Option<Dictionary> { support::child(&self.syntax) }
    #[inline]
    pub fn endstream_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![endstream]) }
    #[inline]
    pub fn raw_bytes_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![raw_bytes]) }
    #[inline]
    pub fn stream_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![stream]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Trailer {
    pub(crate) syntax: SyntaxNode,
}
impl Trailer {
    #[inline]
    pub fn dictionary(&self) -> Option<Dictionary> { support::child(&self.syntax) }
    #[inline]
    pub fn eof_marker_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![eof_marker]) }
    #[inline]
    pub fn int_number_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![int_number]) }
    #[inline]
    pub fn startxref_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![startxref]) }
    #[inline]
    pub fn trailer_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![trailer]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Value {
    pub(crate) syntax: SyntaxNode,
}
impl Value {
    #[inline]
    pub fn direct_object(&self) -> Option<DirectObject> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum DirectObject {
    Array(Array),
    Boolean(Boolean),
    Dictionary(Dictionary),
    HexString(HexString),
    Integer(Integer),
    LiteralString(LiteralString),
    Name(Name),
    Null(Null),
    Real(Real),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ObjectData {
    Array(Array),
    Boolean(Boolean),
    Dictionary(Dictionary),
    HexString(HexString),
    Integer(Integer),
    LiteralString(LiteralString),
    Name(Name),
    Null(Null),
    Real(Real),
    Stream(Stream),
}
impl AstNode for Array {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ARRAY
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ARRAY }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Body {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        BODY
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == BODY }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Boolean {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        BOOLEAN
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == BOOLEAN }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for CrossRefEntry {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        CROSS_REF_ENTRY
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CROSS_REF_ENTRY }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for CrossRefSection {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        CROSS_REF_SECTION
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CROSS_REF_SECTION }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for CrossRefTable {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        CROSS_REF_TABLE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CROSS_REF_TABLE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for DictEntry {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        DICT_ENTRY
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == DICT_ENTRY }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Dictionary {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        DICTIONARY
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == DICTIONARY }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Header {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        HEADER
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == HEADER }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for HexString {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        HEX_STRING
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == HEX_STRING }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for IndirectReference {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        INDIRECT_REFERENCE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == INDIRECT_REFERENCE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Integer {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        INTEGER
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == INTEGER }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Key {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        KEY
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == KEY }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for LiteralString {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        LITERAL_STRING
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LITERAL_STRING }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Name {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        NAME
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Null {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        NULL
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NULL }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Object {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        OBJECT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == OBJECT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ObjectID {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        OBJECT_I_D
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == OBJECT_I_D }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PdfDocument {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PDF_DOCUMENT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PDF_DOCUMENT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PdfVersion {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PDF_VERSION
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PDF_VERSION }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Real {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        REAL
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == REAL }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Stream {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STREAM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STREAM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Trailer {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TRAILER
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TRAILER }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Value {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        VALUE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VALUE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Array> for DirectObject {
    #[inline]
    fn from(node: Array) -> DirectObject { DirectObject::Array(node) }
}
impl From<Boolean> for DirectObject {
    #[inline]
    fn from(node: Boolean) -> DirectObject { DirectObject::Boolean(node) }
}
impl From<Dictionary> for DirectObject {
    #[inline]
    fn from(node: Dictionary) -> DirectObject { DirectObject::Dictionary(node) }
}
impl From<HexString> for DirectObject {
    #[inline]
    fn from(node: HexString) -> DirectObject { DirectObject::HexString(node) }
}
impl From<Integer> for DirectObject {
    #[inline]
    fn from(node: Integer) -> DirectObject { DirectObject::Integer(node) }
}
impl From<LiteralString> for DirectObject {
    #[inline]
    fn from(node: LiteralString) -> DirectObject { DirectObject::LiteralString(node) }
}
impl From<Name> for DirectObject {
    #[inline]
    fn from(node: Name) -> DirectObject { DirectObject::Name(node) }
}
impl From<Null> for DirectObject {
    #[inline]
    fn from(node: Null) -> DirectObject { DirectObject::Null(node) }
}
impl From<Real> for DirectObject {
    #[inline]
    fn from(node: Real) -> DirectObject { DirectObject::Real(node) }
}
impl AstNode for DirectObject {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, ARRAY | BOOLEAN | DICTIONARY | HEX_STRING | INTEGER | LITERAL_STRING | NAME | NULL | REAL) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ARRAY => DirectObject::Array(Array { syntax }),
            BOOLEAN => DirectObject::Boolean(Boolean { syntax }),
            DICTIONARY => DirectObject::Dictionary(Dictionary { syntax }),
            HEX_STRING => DirectObject::HexString(HexString { syntax }),
            INTEGER => DirectObject::Integer(Integer { syntax }),
            LITERAL_STRING => DirectObject::LiteralString(LiteralString { syntax }),
            NAME => DirectObject::Name(Name { syntax }),
            NULL => DirectObject::Null(Null { syntax }),
            REAL => DirectObject::Real(Real { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            DirectObject::Array(it) => &it.syntax,
            DirectObject::Boolean(it) => &it.syntax,
            DirectObject::Dictionary(it) => &it.syntax,
            DirectObject::HexString(it) => &it.syntax,
            DirectObject::Integer(it) => &it.syntax,
            DirectObject::LiteralString(it) => &it.syntax,
            DirectObject::Name(it) => &it.syntax,
            DirectObject::Null(it) => &it.syntax,
            DirectObject::Real(it) => &it.syntax,
        }
    }
}
impl From<Array> for ObjectData {
    #[inline]
    fn from(node: Array) -> ObjectData { ObjectData::Array(node) }
}
impl From<Boolean> for ObjectData {
    #[inline]
    fn from(node: Boolean) -> ObjectData { ObjectData::Boolean(node) }
}
impl From<Dictionary> for ObjectData {
    #[inline]
    fn from(node: Dictionary) -> ObjectData { ObjectData::Dictionary(node) }
}
impl From<HexString> for ObjectData {
    #[inline]
    fn from(node: HexString) -> ObjectData { ObjectData::HexString(node) }
}
impl From<Integer> for ObjectData {
    #[inline]
    fn from(node: Integer) -> ObjectData { ObjectData::Integer(node) }
}
impl From<LiteralString> for ObjectData {
    #[inline]
    fn from(node: LiteralString) -> ObjectData { ObjectData::LiteralString(node) }
}
impl From<Name> for ObjectData {
    #[inline]
    fn from(node: Name) -> ObjectData { ObjectData::Name(node) }
}
impl From<Null> for ObjectData {
    #[inline]
    fn from(node: Null) -> ObjectData { ObjectData::Null(node) }
}
impl From<Real> for ObjectData {
    #[inline]
    fn from(node: Real) -> ObjectData { ObjectData::Real(node) }
}
impl From<Stream> for ObjectData {
    #[inline]
    fn from(node: Stream) -> ObjectData { ObjectData::Stream(node) }
}
impl AstNode for ObjectData {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            ARRAY | BOOLEAN | DICTIONARY | HEX_STRING | INTEGER | LITERAL_STRING | NAME | NULL | REAL | STREAM
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ARRAY => ObjectData::Array(Array { syntax }),
            BOOLEAN => ObjectData::Boolean(Boolean { syntax }),
            DICTIONARY => ObjectData::Dictionary(Dictionary { syntax }),
            HEX_STRING => ObjectData::HexString(HexString { syntax }),
            INTEGER => ObjectData::Integer(Integer { syntax }),
            LITERAL_STRING => ObjectData::LiteralString(LiteralString { syntax }),
            NAME => ObjectData::Name(Name { syntax }),
            NULL => ObjectData::Null(Null { syntax }),
            REAL => ObjectData::Real(Real { syntax }),
            STREAM => ObjectData::Stream(Stream { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ObjectData::Array(it) => &it.syntax,
            ObjectData::Boolean(it) => &it.syntax,
            ObjectData::Dictionary(it) => &it.syntax,
            ObjectData::HexString(it) => &it.syntax,
            ObjectData::Integer(it) => &it.syntax,
            ObjectData::LiteralString(it) => &it.syntax,
            ObjectData::Name(it) => &it.syntax,
            ObjectData::Null(it) => &it.syntax,
            ObjectData::Real(it) => &it.syntax,
            ObjectData::Stream(it) => &it.syntax,
        }
    }
}
impl std::fmt::Display for DirectObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for ObjectData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for Array {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for Body {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for Boolean {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for CrossRefEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for CrossRefSection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for CrossRefTable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for DictEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for Dictionary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for Header {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for HexString {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for IndirectReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for Integer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for Key {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for LiteralString {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for Name {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for Null {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for Object {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for ObjectID {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for PdfDocument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for PdfVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for Real {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for Stream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for Trailer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
impl std::fmt::Display for Value {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { std::fmt::Display::fmt(self.syntax(), f) }
}
